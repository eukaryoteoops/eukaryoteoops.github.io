<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Tony 的開發隨筆</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Tony 的開發隨筆</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Sat, 17 Aug 2019 08:33:56 +0800</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>[.NetCore] Swagger設定</title>
            <link>/posts/2019/08/netcore_swagger/</link>
            <pubDate>Sat, 17 Aug 2019 08:33:56 +0800</pubDate>
            
            <guid>/posts/2019/08/netcore_swagger/</guid>
            <description>Swagger 是讓你方便建立符合API規範的說明文件工具，以下將介紹如何在.Net Core的專案下使用Swagger
透過Nuget安裝 Swashbuckle.AspNetCore 在 Startup 加入設定 public void ConfigureServices(IServiceCollection services) { services.AddSwaggerGen(c =&amp;gt; { //Tag是拿來分類actions，預設的tag是controller name，可以在此修改想要的分類方式 c.TagActionsBy((apiDesc) =&amp;gt; $&amp;quot;{apiDesc.ActionDescriptor.RouteValues[&amp;quot;controller&amp;quot;]}_{apiDesc.HttpMethod}&amp;quot;); //此排序方式非字面上可以排序每個Actions，因為Swagger的文件架構會以path當作分組的依據，此排序只能生效在同一組path裡面 c.OrderActionsBy(api =&amp;gt; api.HttpMethod); //忽略含有[Obsolete]的Actions c.IgnoreObsoleteActions(); //忽略含有[Obsolete]的Properties c.IgnoreObsoleteProperties(); //將Enum轉為文字顯示於介面上，而非數字。 c.DescribeAllEnumsAsStrings(); //若專案內有不同namespace相同名稱的class，此方法可顯示絕對路徑的class name c.CustomSchemaIds(type =&amp;gt; type.FullName); //加入xml，完善API的說明 c.IncludeXmlComments(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, &amp;quot;Api.xml&amp;quot;)); //可以自訂義operation的一些參數，像是在有[Authorized]的operation上加上填寫token的欄位 c.OperationFilter&amp;lt;SwaggerAuthFilter&amp;gt;(); c.SwaggerDoc(&amp;quot;v1&amp;quot;, new Info { Title = &amp;quot;Project&amp;quot;, Version = &amp;quot;v1&amp;quot; }); }); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseSwagger(); app.UseSwaggerUI(opt =&amp;gt; { opt.SwaggerEndpoint(&amp;quot;/swagger/v1/swagger.json&amp;quot;, &amp;quot;v1.0.0&amp;quot;); //摺疊所有分類 opt.DocExpansion(DocExpansion.None); //顯示此要求花費的時長 opt.</description>
            <content type="html"><![CDATA[

<p>Swagger 是讓你方便建立符合API規範的說明文件工具，以下將介紹如何在.Net Core的專案下使用Swagger</p>

<h2 id="透過nuget安裝-swashbuckle-aspnetcore">透過Nuget安裝 Swashbuckle.AspNetCore</h2>

<h2 id="在-startup-加入設定">在 Startup 加入設定</h2>

<pre><code class="language-C#">public void ConfigureServices(IServiceCollection services)
{
    services.AddSwaggerGen(c =&gt;
    {
        //Tag是拿來分類actions，預設的tag是controller name，可以在此修改想要的分類方式
        c.TagActionsBy((apiDesc) =&gt; $&quot;{apiDesc.ActionDescriptor.RouteValues[&quot;controller&quot;]}_{apiDesc.HttpMethod}&quot;);
        //此排序方式非字面上可以排序每個Actions，因為Swagger的文件架構會以path當作分組的依據，此排序只能生效在同一組path裡面
        c.OrderActionsBy(api =&gt; api.HttpMethod);                                                                        
        //忽略含有[Obsolete]的Actions
        c.IgnoreObsoleteActions();                                                                                      
        //忽略含有[Obsolete]的Properties
        c.IgnoreObsoleteProperties();           
        //將Enum轉為文字顯示於介面上，而非數字。                                                                       
        c.DescribeAllEnumsAsStrings();                   
        //若專案內有不同namespace相同名稱的class，此方法可顯示絕對路徑的class name                                                             
        c.CustomSchemaIds(type =&gt; type.FullName);                                                   
        //加入xml，完善API的說明          
        c.IncludeXmlComments(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, &quot;Api.xml&quot;));     
        //可以自訂義operation的一些參數，像是在有[Authorized]的operation上加上填寫token的欄位                     
        c.OperationFilter&lt;SwaggerAuthFilter&gt;();
        c.SwaggerDoc(&quot;v1&quot;, new Info { Title = &quot;Project&quot;, Version = &quot;v1&quot; });
    });
}

public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseSwagger();
    app.UseSwaggerUI(opt =&gt;
    {
        opt.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;v1.0.0&quot;);
        //摺疊所有分類
        opt.DocExpansion(DocExpansion.None);
        //顯示此要求花費的時長
        opt.DisplayRequestDuration();
        //顯示Action Name
        opt.DisplayOperationId();
    });
}
</code></pre>

<h2 id="讓專案建置時產出xml檔案">讓專案建置時產出XML檔案</h2>

<ul>
<li>開啟專案屬性 &gt; 建置標籤 (若要在其他環境下也使用Swagger，組態方面要選取<strong>所有組態</strong>，以免部屬到其他環境缺少XML而報錯)</li>
<li>底下輸出區塊，XML文件檔案打勾</li>
<li>填入與上一步驟 <code>c.IncludeXmlComments()</code>相同的XML檔案名稱</li>
<li>此時建置後，會在專案目錄下產出XML檔案，接著在XML檔案內容 &gt; 複製到輸出目錄，選取永遠複製</li>
</ul>

<h2 id="使用swagger">使用Swagger</h2>

<p>設定完畢之後，可以試試偵錯專案，在Url輸入 <code>http://{yourDebugDomain:port}/swagger</code> ，就可以看到Swagger的介面囉</p>
]]></content>
        </item>
        
        <item>
            <title>Net面試題</title>
            <link>/posts/2019/08/netcore_startup/</link>
            <pubDate>Fri, 16 Aug 2019 16:13:11 +0800</pubDate>
            
            <guid>/posts/2019/08/netcore_startup/</guid>
            <description>.Net interview String &amp;amp; string  string 為 String 的別名，兩者在Compile上並無差別 繼承時，必須使用別名  Stack &amp;amp; Heap  stack 為靜態配置，不同執行緒使用不同stack heap 為動態配置，不同執行緒使用相同heap  Reference type &amp;amp; Value type  String is Reference type Value type use stack only Reference type use Stack as variable address but point to object in Heap  ref &amp;amp; out  ref 需要在執行前初始化參數(給值) out 是在程式結束前需要初始化參數(給值) ref 可以看成 y 指向 i，所以y的操作就都是在改i
int i = 5; Func(ref i); //i = 10 public void Func (int y){ y = 10 }   reference type with ref stack &amp;amp; heap pic</description>
            <content type="html"><![CDATA[

<h1 id="net-interview">.Net interview</h1>

<h2 id="string-string">String &amp; string</h2>

<ul>
<li>string 為 String 的別名，兩者在Compile上並無差別</li>
<li>繼承時，必須使用別名</li>
</ul>

<h2 id="stack-heap">Stack &amp; Heap</h2>

<ul>
<li>stack 為靜態配置，不同執行緒使用不同stack</li>
<li>heap 為動態配置，不同執行緒使用相同heap</li>
</ul>

<h2 id="reference-type-value-type">Reference type &amp; Value type</h2>

<ul>
<li>String is Reference type</li>
<li>Value type use stack only</li>
<li>Reference type use <strong>Stack</strong> as variable address but point to object in <strong>Heap</strong></li>
</ul>

<h2 id="ref-out">ref &amp; out</h2>

<ul>
<li>ref 需要在執行前初始化參數(給值)</li>
<li>out 是在程式結束前需要初始化參數(給值)</li>

<li><p>ref 可以看成 y 指向 i，所以y的操作就都是在改i</p>

<pre><code>int i = 5;
Func(ref i);
//i = 10

public void Func (int y){
y = 10
}
</code></pre></li>
</ul>

<p><a href="https://dotblogs.com.tw/jackeir/2015/06/22/151626">reference type with ref</a>
<a href="https://dotblogs.com.tw/jackeir/2015/06/22/151626">stack &amp; heap pic</a></p>

<h2 id="class-struct">Class &amp; Struct</h2>

<ul>
<li>struct is value type</li>
<li>class is reference type</li>
<li>struct 不可有無參數的ctor，struct不須new()</li>
</ul>

<h2 id="float-double-decimal">Float, Double &amp; Decimal</h2>

<ul>
<li>Float - 7 digits (32 bit)</li>
<li>Double - 15-16 digits (64 bit)</li>
<li>Decimal - 28-29 significant digits (128 bit)</li>
</ul>

<h2 id="ienumerable-iqueryable">IEnumerable &amp; IQueryable</h2>

<ul>
<li>IQueryable(T) 是給資料庫廠商實作的查詢(Linq to Entities)，用來產生資料庫語法，會在資料庫進行操作</li>
<li>IEnumerable(T) 是操作記憶體的查詢(Linq to Objects)
<a href="https://dotblogs.azurewebsites.net/kevin_date/2017/09/20/104713">參考</a></li>
</ul>

<h2 id="delegate-event">delegate &amp; event</h2>

<ul>
<li>Event += 在Event被觸發時會呼叫的委派function</li>

<li><p>委派function，參數及回傳必須與delegate相同</p>

<pre><code>public class Calculator{
public delegate void Sum();
public event Sum SumEvent;
public void Trigger(){
    SumEvent();
}
}

public static void Main(string[] args){
Calculator c = new Calculator();
c.SumEvent += new Calculator.Sum(()=&gt;Console.WriteLine(&quot;1 + 1 = 2&quot;));
c.SumEvent += new Calculator.Sum(()=&gt;Console.WriteLine(&quot;2 + 2 = 4&quot;));
c.SumEvent += new Calculator.Sum(()=&gt;Console.WriteLine(&quot;4 + 4 = 8&quot;));
c.Trigger();
}
</code></pre></li>
</ul>

<h2 id="visual-studio-code">Visual Studio Code</h2>

<p><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf">Hotkey</a></p>
]]></content>
        </item>
        
    </channel>
</rss>
